## 暴力生成数独终局的相关研究

暴力生成数独终局代码：

````c++
int GenFinal(int tolerance)
{
	srand(time(NULL));
	vector<vector<char>> output(9, vector<char>(9, 0));
	int tries = 0;
	for (int i = 0; i < 9; i++)
	{
		int curTries = tries;
		for (int j = 0; j < 9; j++)
		{
retry:		tries++;
			if (curTries + tolerance == tries)
			{
				output[i] = vector<char>(9, 0);
				i--;
				break;
			}
			int t = rand() % 9 + 1;
			for (int k = 0; k < 9; k++)
			{
				if (output[k][j] == t || output[i][k] == t)
				{
					goto retry;
				}
			}
			output[i][j] = t;
			curTries = tries;
		}
	}
	/*for (int i = 0; i < 9; i++)
	{
		for (int j = 0; j < 9; j++)
		{
			cout << char(output[i][j] + '0') << " ";
		}
		cout << endl;
	}*/
	return tries;
}
````

​		通过采用不同的失败容忍度，可以得到产生一个数独终局的尝试次数。这个次数将是相当波动的，因此我们将数独终局产生函数运行1000次来取平均。

| 失败容忍度tolerance | 尝试次数/1000次 | 耗费时间/1000次 |
| ------------------- | --------------- | --------------- |
| 9                   | 3011037         | 2.254           |
| 10                  | 2868656         | 1.952           |
| 11                  | 4105478         | 2.705           |
| 12                  | 2687128         | 1.734           |
| 13                  | 1448420         | 0.943           |
| 14                  | 977322          | 0.627           |
| 15                  | 1940431         | 1.219           |
| 16                  | 1506308         | 0.944           |
| 17                  | 2536552         | 1.515           |
| 18                  | 716933          | 0.454           |
| 19                  | 759000          | 0.481           |
| 20                  | 1243998         | 0.753           |
| 21                  | 1001256         | 0.608           |
| 22                  | 654000          | 0.424           |
| 23                  | 1146070         | 0.693           |
| 24                  | 794000          | 0.488           |
| 25                  | 1836785         | 1.059           |
| 26                  | 1704936         | 0.993           |
| 27                  | 1414211         | 0.83            |

​		根据猜想，在最初的一个范围内，容忍度越高耗费尝试次数越少，因为9次尝试并不一定能得到全部9个需要的数，容忍度的略微提升有效防止了“这个格子其实有数可填但是我没等到直接打回去重来了”的情况；但随着容忍度的继续提高，程序在出现“这个格子填哪个数都有问题但是我就是要试够那么多次才能走”的情况时产生的失败惩罚逐渐提升，导致尝试次数因此变多。理论上应该是一个对勾函数的样子，但是实际数据因为随机数的随机性无法呈现出想要的结果。

​		根据这个想法升级一下，如果我每次都用一个小数组记录一下已经roll出的随机数，让它不要重复好不好？现实地说并不好，对所有的tolerance∈[9, 27]，耗费时间提升了1\~2倍不等，因此我们采取~~黑暗剑~~22作为暴力生成的失败容忍度。

​		这是一篇没有意义的研究报告，不会真的有人暴力生成的吧???~~快进到快交作业了也没想出第二种办法~~